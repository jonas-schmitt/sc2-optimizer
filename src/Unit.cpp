#include<utility>
#include<functional>
#include<cmath>
#include<list>

#include "../include/Unit.h"

using std::pair;
using std::function;
using std::pow;
using std::sqrt;
using std::list;
using std::string;


BaseUnit::BaseUnit(){}

BaseUnit::BaseUnit(string name) : mName(name)
{
	currentForce = std::make_pair<double,double>(0,0);
}

BaseUnit::BaseUnit(UnitStats const& baseStats) : mStats(baseStats)
{
	currentForce = std::make_pair<double,double>(0,0);
}

BaseUnit::BaseUnit(UnitStats const& baseStats, pair<double,double>min, pair<double,double>max)
    : mStats(baseStats), mMinPos(min), mMaxPos(max)
{
	currentForce = std::make_pair<double,double>(0,0);
}

BaseUnit::BaseUnit(BaseUnit const& baseUnit) : mStats(baseUnit.mStats), mPos(baseUnit.mPos), mMinPos(baseUnit.mMinPos), mMaxPos(baseUnit.mMaxPos),
    mFriendFunc(baseUnit.mFriendFunc), mEnemyFunc(baseUnit.mEnemyFunc)
{
	currentForce = std::make_pair<double,double>(0,0);
}

/* Computes the force that is generated by this BaseUnit */
pair<double,double> BaseUnit::computeFriendForce(BaseUnit const& other)
{
    return mFriendFunc(*this,other);
}

pair<double,double> BaseUnit::computeEnemyForce(BaseUnit const& other)
{
    return mEnemyFunc(*this,other);
}

double BaseUnit::computeFriendPot(BaseUnit const&)
{
	//return mFriendFuncPot(*this, other);
	return 0;
}

double BaseUnit::computeEnemyPot(BaseUnit const&)
{
	//return mEnemyFuncPot(*this, other);
	return 0;
}

void BaseUnit::setName(string name)
{
    mName = name;
}

string BaseUnit::getName() const
{
    return mName;
}

// getter and setter
void BaseUnit::setStats(const UnitStats& newStats)
{
    this->mStats = newStats;
}

float BaseUnit::getMinerals() const
{
    return mStats.minerals;
}

float BaseUnit::getGas() const
{
    return mStats.gas;
}

float BaseUnit::getGdps() const
{
    return mStats.gdps;
}

float BaseUnit::getAdps() const
{
    return mStats.adps;
}

float BaseUnit::getGroundRange() const
{
    return mStats.groundRange+mStats.size;
}

float BaseUnit::getAirRange() const
{
    return mStats.airRange+mStats.size;
}

double BaseUnit::getHealth() const
{
    return mStats.health;
}

double BaseUnit::getMaxHealth() const
{
    return mStats.maxHealth;
}

double BaseUnit::getShield() const
{
    return mStats.shield;
}

double BaseUnit::getMaxShield() const
{
    return mStats.maxShield;
}

float BaseUnit::getArmor() const
{
    return mStats.armor;
}


float BaseUnit::getSpeed() const
{
    return mStats.speed;
}


double BaseUnit::getEnergy() const
{
    return mStats.energy;
}

double BaseUnit::getMaxEnergy() const
{
    return mStats.maxEnergy;
}

size_t BaseUnit::getHash() const
{
    return mGenes.getHash();
}

bool BaseUnit::isAirUnit() const
{
    return mStats.airUnit;
} //returns true, if its an air unit

float BaseUnit::getSize() const
{
	return mStats.size;
}


void BaseUnit::addHealth(double const value)
{
    if(mStats.health + value > mStats.maxHealth)
    {
        mStats.health = mStats.maxHealth;
    }
    else
    {
        mStats.health += value;
    }
}

void BaseUnit::subHealth(double const value)
{
    if(mStats.health < EPS)
    {
        mStats.health = 0.0;
        return;
    }
    mStats.health = mStats.health > value ? mStats.health - value : 0.0;
}

void BaseUnit::addShield(double const value)
{
    if(mStats.shield + value > mStats.maxShield)
    {
        mStats.shield = mStats.maxShield;
    }
    else
    {
        mStats.shield += value;
    }
}

void BaseUnit::subShield(double const value)
{
    if(mStats.shield < EPS)
    {
        mStats.shield = 0;
        return;
    }
    mStats.shield = mStats.shield > value ? mStats.shield - value : 0;
}

void BaseUnit::resetHealth()
{
    mStats.health = mStats.maxHealth;
}

void BaseUnit::resetShield()
{
    mStats.shield = mStats.maxShield;
}

void BaseUnit::resetEnergy()
{
    mStats.energy = mStats.maxEnergy;
}

void BaseUnit::incArmor()
{
    ++mStats.armor;
}

void BaseUnit::decArmor()
{
    --mStats.armor;
}

pair<double,double> BaseUnit::getPos() const
{
    return mPos;
}

pair<double,double> BaseUnit::getMinPos() const
{
    return mMinPos;
}

pair<double,double> BaseUnit::getMaxPos() const
{
    return mMaxPos;
}

double BaseUnit::getX() const
{
    return mPos.first;
}

double BaseUnit::getY() const
{
    return mPos.second;
}

void BaseUnit::setPos(double const x, double const y)
{
    setX(x);
    setY(y);
}

void BaseUnit::setPos(const pair<double,double> pos)
{
    setX(pos.first);
    setY(pos.second);
}

void BaseUnit::setX(double const x)
{
    if(x < mMinPos.first)
    {
        mPos.first = mMinPos.first;
    }
    else if(x > mMaxPos.first)
    {
        mPos.first = mMaxPos.first;
    }
    else
    {
        mPos.first = x;
    }
}

void BaseUnit::setY(double const y)
{

    if(y < mMinPos.second)
    {
        mPos.second = mMinPos.second;
    }
    else if(y > mMaxPos.second)
    {
        mPos.second = mMaxPos.second;
    }
    else
    {
        mPos.second = y;
    }
}


void BaseUnit::setMinPos(pair<double,double> const pos)
{
    mMinPos = pos;
}

void BaseUnit::setMaxPos(pair<double,double> const pos)
{
    mMaxPos = pos;
}

void BaseUnit::setFriendForce(function<pair<double,double>(BaseUnit const&, BaseUnit const&)> func)
{
    mFriendFunc = func;
}
void BaseUnit::setEnemyForce(function<pair<double,double>(BaseUnit const&, BaseUnit const&)> func)
{
    mEnemyFunc = func;
}


float BaseUnit::getResources() const
{
    return mStats.minerals+GASTOMINERALS*mStats.gas;
}


float BaseUnit::getAirAttack() const
{
    return mStats.airAttack;
}


int BaseUnit::getGACooldown() const
{
    return mStats.gaCooldown;
}


int BaseUnit::getAACooldown() const
{
    return mStats.aaCooldown;
}

float BaseUnit::getGroundAttack() const
{
    return mStats.groundAttack;
}

float BaseUnit::getGAUpgradeBonus() const
{
    return mStats.gaUpgradeBonus;
}
float BaseUnit::getAAUpgradeBonus() const
{
    return mStats.aaUpgradeBonus;
}

float BaseUnit::getArmorUpgradeBonus() const
{
    return mStats.armorUpgradeBonus;
}

int BaseUnit::getAttackUpgrade() const
{
    return mAttackUpgrade;
}

int BaseUnit::getArmorUpgrade() const
{
    return mArmorUpgrade;
}

vector<Attribute> const& BaseUnit::getAttributes() const
{
    return mStats.attributes;
}

vector<Bonus> const& BaseUnit::getBonuses() const
{
    return mStats.bonuses;
}


int BaseUnit::getShieldUpgrade() const
{
    return mShieldUpgrade;
}

void BaseUnit::setShieldUpgrade(int value)
{
    mShieldUpgrade = value;
}

double BaseUnit::getAttackMultiplier() const
{
    return mAttackMultiplier;
}

void BaseUnit::setAttackMultiplier(double value)
{
    mAttackMultiplier = value;
}

double BaseUnit::getDefenseMultiplier() const
{
    return mDefenseMultiplier;
}

void BaseUnit::setDefenseMultiplier(double value)
{
    mDefenseMultiplier = value;
}

double BaseUnit::getDefenseSubtractor() const
{
    return mDefenseSubtractor;
}

void BaseUnit::setDefenseSubtractor(double value)
{
    mDefenseSubtractor = value;
}


Damage BaseUnit::computeTheoreticalDamage(BaseUnit const& other) const
{
    double totalDamage = 0.0;
    if(other.isAirUnit())
    {
        totalDamage += mAttackUpgrade * mStats.aaUpgradeBonus + mStats.airAttack;
    }
    else
    {
        totalDamage += mAttackUpgrade * mStats.gaUpgradeBonus + mStats.groundAttack;
    }
    for(Bonus const& bonus : mStats.bonuses)
    {
        vector<Attribute> const& attributes = other.getAttributes();
        if(std::includes(attributes.begin(), attributes.end(), bonus.attributes.begin(), bonus.attributes.end()))
        {
            totalDamage += mAttackUpgrade * bonus.upgrade + bonus.base;
        }
    }
    double const shield = other.getShield();
    totalDamage *= mAttackMultiplier;
    if(shield > 0)
    {
        totalDamage -= other.getShieldUpgrade() * other.getDefenseMultiplier();
    }
    totalDamage -= other.getDefenseSubtractor();
    double shieldDamage;
    double healthDamage = totalDamage - shield;
    if(healthDamage > 0)
    {
        shieldDamage = shield;
        healthDamage -= (other.getArmorUpgrade() * other.getArmorUpgradeBonus() + other.getArmor()) * other.getDefenseMultiplier();
        if(healthDamage < 0.0)
        {
            healthDamage = 0.0;
        }
    }
    else
    {
        shieldDamage = totalDamage;
        healthDamage = 0.0;
    }
    Damage damage;
    damage.shield = shieldDamage;
    damage.health = healthDamage;
    damage.total = totalDamage;
    if(damage.total < 0.5)
    {
        damage.total = 0.5;
        if(shield > 0.5)
        {
            damage.shield = 0.5;
            damage.health = 0.0;
        }
        else
        {
            damage.shield = shield;
            damage.health = 0.5 - shield;
        }
    }
    return damage;

}

Damage BaseUnit::computeDamage(BaseUnit const& unit) const
{
    if(unit.getHealth() < EPS)
    {
        return Damage();
    }
    double const x = unit.getX() - this->getX();
    double const y = unit.getY() - this->getY();
    double dist = std::sqrt(pow(x,2)+pow(y,2));
    if(std::isnan(dist))
    {
        dist = 0.0;
    }
    if((unit.isAirUnit() && this->getAirRange() > dist)
            || (!unit.isAirUnit() && this->getGroundRange() > dist))
    {
        return computeTheoreticalDamage(unit);
    }
    return Damage();
}

    //TODO Fix this method
bool BaseUnit::attack(BaseUnit& unit)
{
    if(unit.getHealth() < EPS)
    {
        return false;
    }

    Damage const damage = computeDamage(unit);
    if(damage.total < EPS)
    {
        return false;
    }
    if(damage.shield > 0)
    {
        unit.subShield(damage.shield);
    }
    unit.subHealth(damage.health);
    if(unit.isAirUnit())
    {
        this->setAttackTimer(this->getAACooldown());
    }
    else
    {
        this->setAttackTimer(this->getGACooldown());
    }
    return unit.getHealth() < EPS;
}

pair<double,double> BaseUnit::normVecSafe(pair<double,double>const& vec, double const norm) const
{
    pair<double,double> result;
    if(std::isinf (vec.first/norm) || std::isnan(vec.first/norm) || std::isinf (vec.second/norm) || std::isnan(vec.second/norm) || norm < EPS)
    {
        // choose direction that brings the unit as much away from the border as possible

        if(vec.first > EPS)
        {
            result.first = STDLEN;
        }
        else if(vec.first < -EPS)
        {
            result.first = -STDLEN;
        }
        else
        {
            result.first = 0;
        }
        if(vec.second > EPS)
        {
            result.second = STDLEN;
        }
        else if(vec.second < -EPS)
        {
            result.second = -STDLEN;
        }
        else
        {
            result.second = 0;
        }
    }
    else
    {
        result.first = vec.first/norm;
        result.second = vec.second/norm;
    }
    return result;
}

double BaseUnit::getMaxDist() const
{
    double const x = this->mMaxPos.first-this->mMinPos.first;
    double const y = this->mMaxPos.second-this->mMinPos.second;
    return std::sqrt(pow(x,2)+pow(y,2));
}


double BaseUnit::computeRange(BaseUnit const& other) const
{
    return other.isAirUnit() ? this->getAirRange() : this->getGroundRange();
}

int BaseUnit::getXGene(size_t pos) const
{
    return mGenes.getX(pos);
}
int BaseUnit::getYGene(size_t pos) const
{
    return mGenes.getY(pos);
}

void BaseUnit::setGenes(UnitGenes const& genes)
{
    mGenes = genes;
}

void BaseUnit::setTracking(bool const tracking)
{
    mTracking = tracking;
}

void BaseUnit::reservePathStorage(size_t const sz)
{
    mPath.reserve(sz);
}

vector<pair<float,float>> BaseUnit::getPath() const
{
    return mPath;
}

void BaseUnit::clearPath()
{
    mPath.clear();
}



int BaseUnit::getAttackTimer() const
{
    return mAttackTimer;
}
void BaseUnit::setAttackTimer(int value)
{
    mAttackTimer = value;
}

void BaseUnit::decAttackTimer()
{
    if(mAttackTimer < mTimeSlice)
    {
        mAttackTimer = 0;
        return;
    }
    mAttackTimer -= mTimeSlice;
}


int BaseUnit::getTimeSlice() const
{
    return mTimeSlice;
}

void BaseUnit::setTimeSlice(int value)
{
    mTimeSlice = value;
}






TerranUnit::TerranUnit()
    : BaseUnit()
{}

TerranUnit::TerranUnit(string name)
    : BaseUnit(name)
{}

TerranUnit::TerranUnit(const UnitStats& baseStats)
    : BaseUnit(baseStats)
{}

TerranUnit::TerranUnit(const UnitStats& baseStats, pair<double,double>min, pair<double,double>max)
    : BaseUnit(baseStats,min,max)
{}

TerranUnit::TerranUnit(TerranUnit const& terranUnit)
 : BaseUnit(terranUnit)
{}

TerranUnit::TerranUnit(BaseUnit const& baseUnit)
    : BaseUnit(baseUnit)
{}



ZergUnit::ZergUnit()
    : BaseUnit()
{}

ZergUnit::ZergUnit(string name)
    : BaseUnit(name)
{}

ZergUnit::ZergUnit(const UnitStats& baseStats)
    : BaseUnit(baseStats)
{}

ZergUnit::ZergUnit(const UnitStats& baseStats, pair<double,double>min, pair<double,double>max)
    : BaseUnit(baseStats,min,max)
{}

ZergUnit::ZergUnit(ZergUnit const& zergUnit)
 : BaseUnit(zergUnit)
{}

ZergUnit::ZergUnit(BaseUnit const& baseUnit)
    : BaseUnit(baseUnit)
{}








ProtossUnit::ProtossUnit()
    : BaseUnit(), mShieldRegenCount(0)
{}

ProtossUnit::ProtossUnit(string name)
    : BaseUnit(name), mShieldRegenCount(0)
{}

ProtossUnit::ProtossUnit(const UnitStats& baseStats)
    : BaseUnit(baseStats), mShieldRegenCount(0)
{}

ProtossUnit::ProtossUnit(const UnitStats& baseStats, pair<double,double>min, pair<double,double>max)
    : BaseUnit(baseStats,min,max), mShieldRegenCount(0)
{}

ProtossUnit::ProtossUnit(ProtossUnit const& protossUnit)
 : BaseUnit(protossUnit), mShieldRegenCount(0)
{}

ProtossUnit::ProtossUnit(BaseUnit const& baseUnit)
    : BaseUnit(baseUnit), mShieldRegenCount(0)
{}


void ProtossUnit::subShield(double const value)
{
    mShieldRegenCount = 10;
    BaseUnit::subShield(value);
}


Reaper::Reaper()
    : TerranUnit(), mHealthRegenCount(0)
{}

Reaper::Reaper(string name)
    : TerranUnit(name), mHealthRegenCount(0)
{}

Reaper::Reaper(const UnitStats& baseStats)
    : TerranUnit(baseStats), mHealthRegenCount(0)
{}

Reaper::Reaper(const UnitStats& baseStats, pair<double,double>min, pair<double,double>max)
    : TerranUnit(baseStats,min,max), mHealthRegenCount(0)
{}

Reaper::Reaper(Reaper const& Reaper)
 : TerranUnit(Reaper), mHealthRegenCount(0)
{}

Reaper::Reaper(BaseUnit const& baseUnit)
    : TerranUnit(baseUnit), mHealthRegenCount(0)
{}

Reaper::Reaper(TerranUnit const& terranUnit)
    : TerranUnit(terranUnit), mHealthRegenCount(0)
{}

void Reaper::subHealth(double const value)
{
    mHealthRegenCount = 10;
    BaseUnit::subHealth(value);
}


